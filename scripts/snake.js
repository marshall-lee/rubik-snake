// Generated by CoffeeScript 1.7.1
var ANGLE_D, requestAnimFrame,
  __slice = [].slice,
  __modulo = function(a, b) { return (a % b + +b) % b; };

requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(c) {
  return window.setTimeout(c, 15);
};

ANGLE_D = 5;

$(window).on("load", function() {
  var canvas, draw, renderer;
  canvas = $('#canvas').get(0);
  renderer = new Phoria.CanvasRenderer(canvas);
  draw = function(formula) {
    var edges, fnAnimate, halfHeight, halfSideA, halfSideB, height, i, makeTurn, mouse, nextStep, plane, point, points, points1, points2, polygons, prism, prisms, rot, scene, sideA, sideB, turns, _i, _j, _len, _len1;
    scene = new Phoria.Scene();
    scene.camera.position = {
      x: -10.0,
      y: 15.0,
      z: -15.0
    };
    scene.perspective.aspect = canvas.width / canvas.height;
    scene.viewport.width = canvas.width;
    scene.viewport.height = canvas.height;
    plane = Phoria.Util.generateTesselatedPlane(8, 8, 0, 20);
    scene.graph.push(Phoria.Entity.create({
      points: plane.points,
      edges: plane.edges,
      polygons: plane.polygons,
      style: {
        shademode: "plain",
        drawmode: "wireframe",
        linewidth: 0.5,
        objectsortmode: "back"
      }
    }));
    sideA = 1.2;
    sideB = Math.sqrt(Math.pow(sideA, 2) / 2);
    halfSideA = sideA / 2;
    halfSideB = sideB / 2;
    height = Math.sqrt(Math.pow(sideB, 2) - Math.pow(sideA / 2, 2));
    halfHeight = height / 2;
    prisms = (function() {
      var _i, _j, _len, _results;
      _results = [];
      for (i = _i = 0; _i < 24; i = ++_i) {
        points1 = [
          {
            x: -14 * halfSideA + (i - 1) * halfSideA,
            y: -halfHeight,
            z: halfSideB
          }, {
            x: -14 * halfSideA + i * halfSideA,
            y: halfHeight,
            z: halfSideB
          }, {
            x: -14 * halfSideA + (i + 1) * halfSideA,
            y: -halfHeight,
            z: halfSideB
          }
        ];
        points2 = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = points1.length; _j < _len; _j++) {
            point = points1[_j];
            _results1.push({
              x: point.x,
              y: point.y,
              z: point.z - sideB
            });
          }
          return _results1;
        })();
        points = __slice.call(points1).concat(__slice.call(points2));
        if (__modulo(i, 2) === 1) {
          for (_j = 0, _len = points.length; _j < _len; _j++) {
            point = points[_j];
            point.y = -point.y;
          }
          points.reverse();
        }
        edges = [
          {
            a: 0,
            b: 1
          }, {
            a: 1,
            b: 2
          }, {
            a: 2,
            b: 0
          }, {
            a: 3,
            b: 4
          }, {
            a: 4,
            b: 5
          }, {
            a: 5,
            b: 3
          }, {
            a: 0,
            b: 3
          }, {
            a: 1,
            b: 4
          }, {
            a: 2,
            b: 5
          }
        ];
        polygons = [
          {
            vertices: [0, 1, 2]
          }, {
            vertices: [5, 4, 3]
          }, {
            vertices: [0, 3, 4, 1]
          }, {
            vertices: [1, 4, 5, 2]
          }, {
            vertices: [0, 2, 5, 3]
          }
        ];
        prism = Phoria.Entity.create({
          points: points,
          edges: edges,
          polygons: polygons,
          style: {
            color: __modulo(i, 2) === 0 ? [0, 0, 0] : [128, 128, 128],
            shademode: "lightsource",
            linewidth: 1,
            linescale: 0,
            drawmode: "wireframe",
            opacity: 0.95,
            objectsortmode: "back"
          }
        });
        _results.push(prism);
      }
      return _results;
    })();
    for (_i = 0, _len = prisms.length; _i < _len; _i++) {
      prism = prisms[_i];
      prism.generatePolygonNormals();
      prism.leftNormal = vec3.clone(prism.polygons[2].normal);
      prism.rightNormal = vec3.clone(prism.polygons[3].normal);
    }
    for (_j = 0, _len1 = prisms.length; _j < _len1; _j++) {
      prism = prisms[_j];
      scene.graph.push(prism);
    }
    scene.graph.push(Phoria.DistantLight.create({
      direction: {
        x: 0,
        y: -0.5,
        z: 1
      }
    }));
    mouse = Phoria.View.addMouseEvents(canvas);
    rot = {
      x: 0,
      y: 0,
      z: 0,
      velx: 0,
      vely: 0,
      velz: 0,
      nowx: 0,
      nowy: 0,
      nowz: 0,
      ratio: 0.1
    };
    makeTurn = function(code, cbDone) {
      var angle, angleDelta, axis, currentAngle, direction, doRotate, doRotateAll, index, middlePrism, mq, n, nRotates, normal, p1, p2, prismSubset, q, slopingSide, transBackVector, transVector, _ref, _ref1;
      n = parseInt(code[0]);
      _ref = code.split(/L|R/), n = _ref[0], nRotates = _ref[1];
      direction = code.match(/L|R/)[0];
      angle = 90 * nRotates;
      index = (n - 1) * 2;
      middlePrism = prisms[index];
      _ref1 = direction === "L" ? [middlePrism.leftNormal, middlePrism.polygons[2]] : direction === "R" ? [middlePrism.rightNormal, middlePrism.polygons[3]] : void 0, normal = _ref1[0], slopingSide = _ref1[1];
      p1 = middlePrism.points[slopingSide.vertices[0]];
      p2 = middlePrism.points[slopingSide.vertices[2]];
      transVector = vec3.fromValues((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);
      transVector = vec3.transformMat4(transVector, transVector, middlePrism.matrix);
      transBackVector = vec3.negate(vec3.create(), transVector);
      axis = vec3.clone(normal);
      angleDelta = ANGLE_D * Phoria.RADIANS;
      if (direction === "R") {
        angleDelta = -angleDelta;
      }
      q = quat.setAxisAngle(quat.create(), axis, angleDelta);
      mq = mat4.fromRotationTranslation(mat4.create(), q, transVector);
      mq = mat4.translate(mq, mq, transBackVector);
      prismSubset = direction === "L" ? prisms.slice(0, index) : prisms.slice(index + 1, 24);
      currentAngle = 0;
      doRotate = function(prism) {
        vec4.transformQuat(prism.leftNormal, prism.leftNormal, q);
        vec4.transformQuat(prism.rightNormal, prism.rightNormal, q);
        return mat4.mul(prism.matrix, mq, prism.matrix);
      };
      doRotateAll = function() {
        var _k, _len2;
        for (_k = 0, _len2 = prismSubset.length; _k < _len2; _k++) {
          prism = prismSubset[_k];
          doRotate(prism);
        }
        currentAngle += ANGLE_D;
        if (currentAngle < angle) {
          return setTimeout(doRotateAll, 1);
        } else {
          return setTimeout(cbDone, 0);
        }
      };
      return setTimeout(doRotateAll, 0);
    };
    turns = formula.split(/\r\n|\n\r|\n|\r/).join("").split("-").reverse();
    nextStep = function() {
      return setTimeout(function() {
        var turn;
        turn = turns.pop();
        if (turn) {
          return makeTurn(turn, nextStep);
        }
      }, 10);
    };
    setTimeout(nextStep, 0);
    fnAnimate = function() {
      var mx, my, mz, qx, qy, qz, _k, _len2;
      rot.nowx += (rot.velx = (mouse.velocityV - rot.x - rot.nowx) * rot.ratio);
      rot.nowy += (rot.vely = (rot.y - rot.nowy) * rot.ratio);
      rot.nowz += (rot.velz = (mouse.velocityH - rot.z - rot.nowz) * rot.ratio);
      qx = quat.setAxisAngle(quat.create(), vec3.fromValues(0, 1, 0), -rot.velz * Phoria.RADIANS);
      mx = mat4.fromQuat(mat4.create(), qx);
      qy = quat.setAxisAngle(quat.create(), vec3.fromValues(0, 1, 0), -rot.vely * Phoria.RADIANS);
      my = mat4.fromQuat(mat4.create(), qy);
      qz = quat.setAxisAngle(quat.create(), vec3.fromValues(0, 0, 1), -rot.velz * Phoria.RADIANS);
      mz = mat4.fromQuat(mat4.create(), qz);
      for (_k = 0, _len2 = prisms.length; _k < _len2; _k++) {
        prism = prisms[_k];
        vec4.transformQuat(prism.leftNormal, prism.leftNormal, qx);
        vec4.transformQuat(prism.rightNormal, prism.rightNormal, qx);
        mat4.mul(prism.matrix, mx, prism.matrix);
        vec4.transformQuat(prism.leftNormal, prism.leftNormal, qy);
        vec4.transformQuat(prism.rightNormal, prism.rightNormal, qy);
        mat4.mul(prism.matrix, my, prism.matrix);
        vec4.transformQuat(prism.leftNormal, prism.leftNormal, qz);
        vec4.transformQuat(prism.rightNormal, prism.rightNormal, qz);
        mat4.mul(prism.matrix, mz, prism.matrix);
      }
      scene.modelView();
      renderer.render(scene);
      return requestAnimFrame(fnAnimate);
    };
    return requestAnimFrame(fnAnimate);
  };
  draw("9R2-9L2-8L2-7R2-6R2-6L2-5L3-4L2- 3R2-2R2-2L2");
  return $("#drawButton").click(function(e) {
    e.preventDefault();
    return draw($("#formula").val());
  });
});
